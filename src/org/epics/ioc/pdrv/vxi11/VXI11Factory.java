/**
 * Copyright - See the COPYRIGHT that is included with this distribution.
 * EPICS JavaIOC is distributed subject to a Software License Agreement found
 * in file LICENSE that is included with this distribution.
 */
package org.epics.ioc.pdrv.vxi11;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;

import org.acplt.oncrpc.OncRpcException;
import org.acplt.oncrpc.OncRpcProtocols;
import org.acplt.oncrpc.XdrVoid;
import org.acplt.oncrpc.server.OncRpcCallInformation;
import org.acplt.oncrpc.server.OncRpcDispatchable;
import org.acplt.oncrpc.server.OncRpcTcpServerTransport;
import org.epics.ioc.pdrv.Status;
import org.epics.ioc.pdrv.vxi11.rpc.Create_LinkParms;
import org.epics.ioc.pdrv.vxi11.rpc.Create_LinkResp;
import org.epics.ioc.pdrv.vxi11.rpc.Device_AddrFamily;
import org.epics.ioc.pdrv.vxi11.rpc.Device_DocmdParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_DocmdResp;
import org.epics.ioc.pdrv.vxi11.rpc.Device_EnableSrqParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_Error;
import org.epics.ioc.pdrv.vxi11.rpc.Device_Flags;
import org.epics.ioc.pdrv.vxi11.rpc.Device_GenericParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_Link;
import org.epics.ioc.pdrv.vxi11.rpc.Device_LockParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_ReadParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_ReadResp;
import org.epics.ioc.pdrv.vxi11.rpc.Device_ReadStbResp;
import org.epics.ioc.pdrv.vxi11.rpc.Device_RemoteFunc;
import org.epics.ioc.pdrv.vxi11.rpc.Device_WriteParms;
import org.epics.ioc.pdrv.vxi11.rpc.Device_WriteResp;
import org.epics.ioc.pdrv.vxi11.rpc.vxi11core;
import org.epics.ioc.pdrv.vxi11.rpc.vxi11core_DEVICE_CORE_Client;
import org.epics.ioc.pdrv.vxi11.rpc.vxi11intr;


/**
 * Factory for code that communicates with the code in the rpc package, which is code
 * generated by Remote Tea.
 * @author mrk
 *
 */
public class VXI11Factory {
    /**
     * Create a VXI11Controller.
     * @param hostName The hostName or INET address.
     * @param vxiName The VXI name.
     * @return The interface for the VXI11Controller.
     */
    public static VXI11Controller create(String hostName,String vxiName){
        Controller controller = new Controller(hostName,vxiName);
        return controller;
    }
    
    private static class ErrorCode {
        static VXI11ErrorCode get(int value) {
            switch (value) {
            case 0:   return VXI11ErrorCode.noError;
            case 1:   return VXI11ErrorCode.syntaxError;
            case 3:   return VXI11ErrorCode.deviceNotAccessable;
            case 4:   return VXI11ErrorCode.invalidLinkIdentifier;
            case 5:   return VXI11ErrorCode.parameterError;
            case 6:   return VXI11ErrorCode.channelNotEstablished;
            case 8:   return VXI11ErrorCode.operationNotSupported;
            case 9:   return VXI11ErrorCode.outOfResources;
            case 11:  return VXI11ErrorCode.deviceLockedByAnotherLink;
            case 12:  return VXI11ErrorCode.noLockHeldByThisLink;
            case 15:  return VXI11ErrorCode.IOTimeout;
            case 17:  return VXI11ErrorCode.IOError;
            case 21:  return VXI11ErrorCode.invalidAddress;
            case 23:  return VXI11ErrorCode.abort;
            case 29:  return VXI11ErrorCode.channelAlreadyEstablished;
            }
            return VXI11ErrorCode.unknown;
        }
        static String getString(int value) {
            switch (value) {
            case 0:   return "No error";
            case 1:   return "Syntax error";
            case 3:   return "Device not accessible";
            case 4:   return "Invalid link identifier";
            case 5:   return "Parameter error";
            case 6:   return "Channel not established";
            case 8:   return "Operation not supported";
            case 9:   return "Out of resources";
            case 11:  return "Device locked by another link";
            case 12:  return "No lock held by this link";
            case 15:  return "I/O timeout";
            case 17:  return "I/O error";
            case 21:  return "Invalid address";
            case 23:  return "Abort";
            case 29:  return "Channel already established";
            }
            return "unknown Device_error code=" + value;
        }
    }

    private static class Controller implements VXI11Controller, OncRpcDispatchable {
        
        private Controller(String hostName,String vxiName) {
            this.hostName = hostName;
            this.vxiName = vxiName;
        }

        private String hostName = null;
        private String vxiName = null;
        private boolean isConnected = false;
        private InetAddress inetAddr = null;
        private vxi11core_DEVICE_CORE_Client coreClient = null;
        private int lockTimeout = 20000;
        private int ioTimeout = 20000;
        private boolean waitLock = false;
        // following is link to controller itself
        private Device_Link lid = null;
        private boolean srqThreadRunning = false;
        private byte srqHandle[] = { };
        private VXI11SrqHandler srqHandler = null;
        private OncRpcTcpServerTransport tcpTrans = null;
        private ArrayList<VXI11Device> deviceList = new ArrayList<VXI11Device>();

        
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#connect(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status connect(VXI11User user) {
            try {
                inetAddr = InetAddress.getByName(hostName);
            } catch (UnknownHostException e) {
                user.setError(VXI11ErrorCode.unknownHostException);
                user.setString(e.getMessage());
                return Status.error;
            }
            try {
                coreClient = new vxi11core_DEVICE_CORE_Client(inetAddr, vxi11core.DEVICE_CORE, vxi11core.DEVICE_CORE_VERSION,OncRpcProtocols.ONCRPC_TCP);
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
            Create_LinkParms clp = new Create_LinkParms();
            clp.lockDevice = false;
            clp.lock_timeout = lockTimeout;
            clp.device = vxiName;
            try {
                Create_LinkResp clr = coreClient.create_link_1(clp);
                VXI11ErrorCode errorCode = ErrorCode.get(clr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    disconnect();
                    user.setError(errorCode);
                    user.setString("Could not create link to controller");
                    return Status.error;
                }
                lid = clr.lid;
                isConnected = true;
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isConnected()
         */
        public boolean isConnected() {
            return isConnected;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#disconnect()
         */
        public void disconnect() {
            for(VXI11Device device :deviceList ) device.disconnect();
            isConnected = false;
            try {
                coreClient.close();
            }
            catch (OncRpcException e) {
                System.err.println(e.getMessage());
            }
            if(tcpTrans!=null) tcpTrans.close();
            coreClient  = null;
            tcpTrans = null;
        }
        /* (non-Javadoc)
         * @see java.lang.Object#finalize()
         */
        protected void finalize() {
           disconnect();
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#createDevice(int, int)
         */
        public VXI11Device createDevice(int pad,int sad)
        {
            String devName = vxiName;
            if(pad>=0) devName += "," + pad;
            if(sad>=0) devName += "," + sad;
            Device device = new Device(devName);
            deviceList.add(device);
            return device;
            
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#getLockTimeout()
         */
        public int getLockTimeout() {
            return lockTimeout;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setLockTimeout(int)
         */
        public void setLockTimeout(int msec) {
            lockTimeout = msec;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#getIoTimeout()
         */
        public int getIoTimeout() {
            return ioTimeout;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setIoTimeout(int)
         */
        public void setIoTimeout(int msec) {
            ioTimeout = msec;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#getWaitLock()
         */
        public boolean getWaitLock() {
            return waitLock;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setWaitLock(boolean)
         */
        public void setWaitLock(boolean state) {
            waitLock = state;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#ifc(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status ifc(VXI11User user) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20010;
            dcp.network_order = true;
            dcp.datasize = 0;
            dcp.data_in = new byte[0];
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("ifc failure");
                    return Status.error;
                }
                return Status.success;
            }  catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#getBusAddress(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status getBusAddress(VXI11User user) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20001;
            dcp.network_order = true;
            dcp.datasize = 2;
            byte d[] = { 0, 8 };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("getBusAddress failure");
                    return Status.error;
                }
                user.setByte(dcr.data_out[1]);
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setBusAddress(org.epics.ioc.pdrv.vxi11.VXI11User, int)
         */
        public Status setBusAddress(VXI11User user,int pad) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            if ((pad < 0) || (pad > 30))
                throw new IllegalArgumentException("Invalid IEEE-488 controller address");
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x2000A;
            dcp.network_order = true;
            dcp.datasize = 4;
            byte d[] = { 0, 0, 0, (byte)pad };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("setBusAddress failure");
                    return Status.error;
                }
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isRemote(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isRemote(VXI11User user) {
            return statusFlag(user,1);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isSRQ(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isSRQ(VXI11User user) {
            return statusFlag(user,2);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isNDAC(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isNDAC(VXI11User user) {
            return statusFlag(user,3);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isControllerInCharge(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isControllerInCharge(VXI11User user) {
            return statusFlag(user,5);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isSystemController(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isSystemController(VXI11User user) {
            return statusFlag(user,4);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isListener(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isListener(VXI11User user) {
            return statusFlag(user,7);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#isTalker(org.epics.ioc.pdrv.vxi11.VXI11User)
         */
        public Status isTalker(VXI11User user) {
            return statusFlag(user,6);
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setATN(org.epics.ioc.pdrv.vxi11.VXI11User, boolean)
         */
        public Status setATN(VXI11User user,boolean state) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20002;
            dcp.network_order = true;
            dcp.datasize = 2;
            byte d[] = { 0, (byte)(state ? 1 : 0) };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("setATN failure");
                    return Status.error;
                }
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setREN(org.epics.ioc.pdrv.vxi11.VXI11User, boolean)
         */
        public Status setREN(VXI11User user,boolean state) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20003;
            dcp.network_order = true;
            dcp.datasize = 2;
            byte d[] = { 0, (byte)(state ? 1 : 0) };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("setREN failure");
                    return Status.error;
                }
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#setREN(org.epics.ioc.pdrv.vxi11.VXI11User, boolean)
         */
        public Status passControl(VXI11User user,int addr) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20004;
            dcp.network_order = true;
            dcp.datasize = 4;
            byte d[] = { 0, 0,0,(byte)addr };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("passControl failure");
                    return Status.error;
                }
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#sendCommand(org.epics.ioc.pdrv.vxi11.VXI11User, byte[])
         */
        public Status sendCommand(VXI11User user,byte data[]) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20004;
            dcp.network_order = true;
            dcp.datasize = data.length;
            dcp.data_in = data;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("passControl failure");
                    return Status.error;
                }
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#enableSRQ(org.epics.ioc.pdrv.vxi11.VXI11User, boolean)
         */
        public Status enableSRQ(VXI11User user,boolean state) {
            /*
             * Create the interrupt channel and start the
             * SRQ handler thread if necessary.
             */
            if (!srqThreadRunning) {
                if (state == false) return Status.success;
                /*
                 * Destroy any interrupt channel left over from before.
                 * Ignore return value since only possible values are
                 * `success' and `channel not established', both of which
                 * indicate that the interrupt channel is not present.
                 */
                try {
                    coreClient.destroy_intr_chan_1();
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                /*
                 * Create the interrupt channel
                 */
                Device_RemoteFunc drf = new Device_RemoteFunc();
                try {
                    byte b[] = InetAddress.getLocalHost().getAddress();
                    drf.hostAddr = ((b[0] << 24) & 0xFF000000) |
                    ((b[1] << 16) & 0x00FF0000) |
                    ((b[2] <<  8) & 0x0000FF00) |
                    (b[3]         & 0x000000FF);
                }
                catch (UnknownHostException e) {
                    user.setError(VXI11ErrorCode.unknownHostException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                /*
                 * Start the RPC server
                 */
                try {
                    tcpTrans =
                        new OncRpcTcpServerTransport(this,
                                0,
                                vxi11intr.DEVICE_INTR,
                                vxi11intr.DEVICE_INTR_VERSION,
                                1024);
                    
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                tcpTrans.listen();
                drf.hostPort = (short)tcpTrans.getPort();
                drf.progNum = vxi11intr.DEVICE_INTR;
                drf.progVers = vxi11intr.DEVICE_INTR_VERSION;
                drf.progFamily = Device_AddrFamily.DEVICE_TCP;
                try {
                    Device_Error de = coreClient.create_intr_chan_1(drf);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("create_intr_chan failure");
                        return Status.error;
                    }
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                srqThreadRunning = true;
            }
            /*
             * Enable/Disable SRQ messages
             */
            Device_EnableSrqParms des = new Device_EnableSrqParms();
            des.lid = lid;
            des.enable = state;
            des.handle = srqHandle;
            try {
                Device_Error de = coreClient.device_enable_srq_1(des);
                VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("enable_srq failure");
                    return Status.error;
                }
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
            return Status.success;
        }
        /* (non-Javadoc)
         * @see org.epics.ioc.pdrv.vxi11.VXI11Controller#registerSrqHandler(org.epics.ioc.pdrv.vxi11.VXI11SrqHandler)
         */
        public void registerSrqHandler(VXI11SrqHandler srqHandler) {
            this.srqHandler = srqHandler;
        }
        /* (non-Javadoc)
         * @see org.acplt.oncrpc.server.OncRpcDispatchable#dispatchOncRpcCall(org.acplt.oncrpc.server.OncRpcCallInformation, int, int, int)
         */
        public void dispatchOncRpcCall(OncRpcCallInformation call,
                int program, int version, int procedure)
        {
            if ((program != vxi11intr.DEVICE_INTR)
                    || (version != vxi11intr.DEVICE_INTR_VERSION)
                    || (procedure != 30)) {
                try {
                    call.failProcedureUnavailable();
                }
                catch (OncRpcException e) { System.out.println("VXI11SRQ " + e.getMessage()); }
                catch (IOException e) { System.out.println("VXI11SRQ " + e.getMessage());  }
                return;
            }
            if (srqHandler != null)
                srqHandler.srqHandler(this);
            try {
                call.reply(XdrVoid.XDR_VOID);
            }
            catch (OncRpcException e) { System.out.println("VXI11SRQ " + e.getMessage()); }
            catch (IOException e) { System.out.println("VXI11SRQ " + e.getMessage());  }
        }
        
        private Status statusFlag(VXI11User user,int code) {
            Device_DocmdParms dcp = new Device_DocmdParms();
            dcp.lid = lid;
            dcp.flags = new Device_Flags(waitLock ? 1 : 0);
            dcp.io_timeout = ioTimeout;
            dcp.lock_timeout = lockTimeout;
            dcp.cmd = 0x20001;
            dcp.network_order = true;
            dcp.datasize = 2;
            byte d[] = { 0, (byte)code };
            dcp.data_in = d;
            try {
                Device_DocmdResp dcr = coreClient.device_docmd_1(dcp);
                VXI11ErrorCode errorCode = ErrorCode.get(dcr.error.value);
                if(errorCode!=VXI11ErrorCode.noError) {
                    user.setError(errorCode);
                    user.setString("docmd failure");
                    return Status.error;
                }
                user.setByte(dcr.data_out[1]);
                return Status.success;
            } catch (OncRpcException e) {
                user.setError(VXI11ErrorCode.RPCException);
                user.setString(e.getMessage());
                return Status.error;
            } catch (IOException e) {
                user.setError(VXI11ErrorCode.IOException);
                user.setString(e.getMessage());
                return Status.error;
            }
        }
        
        private class Device implements VXI11Device {
            
            private Device(String devName) {
                this.devName = devName;
            }
            
            private String devName = null;
            private boolean isConnected = false;
            private Device_Link lid = null;
            private boolean eoi = true;
            private int termChar = -1;
            private int maxRecvSize = 0;

            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#connect(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status connect(VXI11User user) {
                Create_LinkParms clp = new Create_LinkParms();
                clp.lockDevice = false;
                clp.lock_timeout = lockTimeout;
                clp.device = devName;
                try {
                    Create_LinkResp clr = coreClient.create_link_1(clp);
                    VXI11ErrorCode errorCode = ErrorCode.get(clr.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("create_link failure");
                        return Status.error;
                    }
                    lid = clr.lid;
                    if(maxRecvSize==0) {
                        maxRecvSize = clr.maxRecvSize;
                    } else if (maxRecvSize!=clr.maxRecvSize) {
                        user.setError(VXI11ErrorCode.unknown);
                        user.setString("maxRecvSize changed");
                    }
                    isConnected = true;
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#isConnected()
             */
            public boolean isConnected() {
                return isConnected;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#disconnect()
             */
            public void disconnect() {
                isConnected = false;
                try {
                    coreClient.destroy_link_1(lid);
                }
                catch (OncRpcException e) {
                    System.err.println(e.getMessage());
                }
                catch (IOException e) {
                    System.err.println(e.getMessage());
                }
                coreClient  = null;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#trigger(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status trigger(VXI11User user) {
                Device_GenericParms dgp = new Device_GenericParms();

                dgp.lid = lid;
                dgp.flags = new Device_Flags(waitLock ? 1 : 0);
                dgp.io_timeout = ioTimeout;
                dgp.lock_timeout = lockTimeout;
                try {
                    Device_Error de = coreClient.device_trigger_1(dgp);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("trigger failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#clear(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status clear(VXI11User user) {
                Device_GenericParms dgp = new Device_GenericParms();

                dgp.lid = lid;
                dgp.flags = new Device_Flags(waitLock ? 1 : 0);
                dgp.io_timeout = ioTimeout;
                dgp.lock_timeout = lockTimeout;
                try {
                    Device_Error de = coreClient.device_clear_1(dgp);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("clear failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#lock(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status lock(VXI11User user) {
                Device_LockParms dlp = new Device_LockParms();

                dlp.lid = lid;
                dlp.flags = new Device_Flags(waitLock ? 1 : 0);
                dlp.lock_timeout = lockTimeout;
                try {
                    Device_Error de = coreClient.device_lock_1(dlp);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("lock failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#unlock(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status unlock(VXI11User user) {
                try {
                    Device_Error de = coreClient.device_unlock_1(lid);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("unlock failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#getEOI()
             */
            public boolean getEOI() {
                return eoi;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#setEOI(boolean)
             */
            public void setEOI(boolean eoi) {
                this.eoi = eoi;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#getTermChar()
             */
            public int getTermChar() {
                return termChar;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#setTermChar(int)
             */
            public Status setTermChar(VXI11User user,int termChar) {
                if (termChar > 255) {
                    user.setError(VXI11ErrorCode.parameterError);
                    user.setString("Invalid terminating character");
                    return Status.error;
                }
                this.termChar = termChar;
                return Status.success;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#write(org.epics.ioc.pdrv.vxi11.VXI11User, byte[], int)
             */
            public Status write(VXI11User user,byte[] data,int nbytes) {
                if(nbytes<=0) {
                    user.setError(VXI11ErrorCode.noError);
                    user.setString("request for <= 0 bytes");
                    return Status.error;
                }
                Device_WriteParms dwp = new Device_WriteParms();
                dwp.lid = lid;
                dwp.io_timeout = ioTimeout;
                dwp.lock_timeout = lockTimeout;
                dwp.data = new byte[nbytes];
                System.arraycopy(data, 0, dwp.data, 0, nbytes);
                if(eoi) {
                    dwp.flags = new Device_Flags(0x8 | (waitLock ? 1 : 0));
                } else {
                    dwp.flags = new Device_Flags(waitLock ? 1 : 0);
                }
                try {
                    Device_WriteResp dwr = coreClient.device_write_1(dwp);
                    VXI11ErrorCode errorCode = ErrorCode.get(dwr.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("write failure");
                        return Status.error;
                    }
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                return Status.success;
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#read(org.epics.ioc.pdrv.vxi11.VXI11User, byte[], int)
             */
            public Status read(VXI11User user,byte[] data, int maxCount) {
                try {
                    Device_ReadParms drp = new Device_ReadParms();
                    drp.lid = lid;
                    drp.io_timeout = ioTimeout;
                    drp.lock_timeout = lockTimeout;
                    
                    if (termChar >= 0) {
                        drp.flags = new Device_Flags(0x80 | (waitLock ? 1 : 0));
                        drp.termChar = (byte)termChar;
                    }
                    else {
                        drp.flags = new Device_Flags(waitLock ? 1 : 0);
                    }
                    int nextByte = 0;
                    if(maxCount<0 || maxCount>data.length) maxCount = data.length;
                    for (;;) {
                        drp.requestSize = maxCount - nextByte;
                        Device_ReadResp drr = coreClient.device_read_1(drp);
                        VXI11ErrorCode errorCode = ErrorCode.get(drr.error.value);
                        if(errorCode!=VXI11ErrorCode.noError) {
                            user.setError(errorCode);
                            user.setString("read failure");
                            return Status.error;
                        }
                        int nowLength = drr.data.length;
                        System.arraycopy(drr.data, 0, data, nextByte, nowLength);
                        nextByte += nowLength;
                        /*
                         * Quit if end received
                         * or if specified number of characters have been received.
                         */
                        if (((drr.reason & 0x7) != 0)) {
                            user.setReason(drr.reason);
                            user.setInt(nextByte);
                            return Status.success;
                        }
                    }
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#getStatusByte(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status getStatusByte(VXI11User user) {
                Device_GenericParms dgp = new Device_GenericParms();

                dgp.lid = lid;
                dgp.flags = new Device_Flags(waitLock ? 1 : 0);
                dgp.io_timeout = ioTimeout;
                dgp.lock_timeout = lockTimeout;
                try {
                    Device_ReadStbResp dsb = coreClient.device_readstb_1(dgp);
                    coreClient.destroy_intr_chan_1();
                    VXI11ErrorCode errorCode = ErrorCode.get(dsb.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("getStatusByte failure");
                        return Status.error;
                    }
                    user.setByte(dsb.stb);
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
                
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#remote(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status remote(VXI11User user) {
                Device_GenericParms dgp = new Device_GenericParms();
                dgp.lid = lid;
                dgp.flags = new Device_Flags(waitLock ? 1 : 0);
                dgp.io_timeout = ioTimeout;
                dgp.lock_timeout = lockTimeout;
                try {
                    Device_Error de = coreClient.device_remote_1(dgp);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("remote failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
            /* (non-Javadoc)
             * @see org.epics.ioc.pdrv.vxi11.VXI11Device#local(org.epics.ioc.pdrv.vxi11.VXI11User)
             */
            public Status local(VXI11User user) {
                Device_GenericParms dgp = new Device_GenericParms();

                dgp.lid = lid;
                dgp.flags = new Device_Flags(waitLock ? 1 : 0);
                dgp.io_timeout = ioTimeout;
                dgp.lock_timeout = lockTimeout;
                try {
                    Device_Error de = coreClient.device_local_1(dgp);
                    VXI11ErrorCode errorCode = ErrorCode.get(de.error.value);
                    if(errorCode!=VXI11ErrorCode.noError) {
                        user.setError(errorCode);
                        user.setString("local failure");
                        return Status.error;
                    }
                    return Status.success;
                } catch (OncRpcException e) {
                    user.setError(VXI11ErrorCode.RPCException);
                    user.setString(e.getMessage());
                    return Status.error;
                } catch (IOException e) {
                    user.setError(VXI11ErrorCode.IOException);
                    user.setString(e.getMessage());
                    return Status.error;
                }
            }
        }
    }
    
}
